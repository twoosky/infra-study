# 사용자 수에 따른 규모 확장성
* [단일 서버](#단일-서버)
* [데이터 베이스](#데이터베이스)
* [수직적 규모 확장 vs 수평적 규모 확장](#수직적-규모-확장-vs-수평적-규모-확장)
* [로드밸런서](#로드밸런서)
* [데이터베이스 다중화](#데이터베이스-다중화)
* [캐시](#캐시)
* [콘텐츠 전송 네트워크(CDN)](#콘텐츠-전송-네트워크cdn)
* [무상태(stateless) 웹 계층](#무상태stateless-웹-계층)

## 단일 서버
* 사용자의 요청이 처리되는 과정

<img src="https://user-images.githubusercontent.com/50009240/164426609-345c3427-5587-4887-8d77-f0faa60b8605.png" height="370" width="700">

1. 사용자가 웹 브라우저에 URL(도메인 이름) 입력한다.
2. 입력된 URL 정보는 DNS에서 IP 주소로 변환되어 반환된다.
3. 해당 IP주소의 웹 서버로 HTTP 요청이 전달된다.
4. 요청을 받은 웹 서버는 HTML 페이지나 JSON 형턔의 응답을 반환한다.

## 데이터베이스
사용자가 늘면 서버 하나로는 충분하지 않아, 여러 서버를 두어야 한다.  
여러 서버를 두어 하나는 웹/모바일 트래픽 처리 용도, 다른 하나는 데이터베이스용으로 사용한다.  
서버를 분리하면 `웹 계층`과 `데이터 계층` 각각을 독립적으로 확장해 나갈 수 있게 된다.

<img src="https://user-images.githubusercontent.com/50009240/164429189-fc711995-5fb7-489a-bc1b-2204d6cb8f59.png" height="370" width="700">

**어떤 데이터베이스를 사용할 것인가?**  
* `RDBMS`는 자료를 테이블과 열, 칼럼으로 표현한다. 여러 테이블에 있는 데이터를 조인(join)하여 합칠 수 있다.  
* `NoSQL`은 키-값 저장소, 그래프 저장소, 칼럼 저장소, 문서 저장소로 나눌 수 있다. 조인(join) 연산을 지원하지 않는다.
* `RDBMS`를 사용하는 것이 최선일 수 있지만, 아래와 같은 경우에는 `NoSQL`이 바람직한 선택일 수 있다. 
  * 아주 낮은 응답 지연시간(latency)이 요구됨
  * 다루는 데이터가 비정형이라 관게형 데이터가 아님
  * 데이터(JSON, YAML, XML 등)을 직력화하거나 역직렬화할 수 있기만 하면 됨
  * 아주 많은 양의 데이터를 저장할 필요가 있음

## 수직적 규모 확장 vs 수평적 규모 확장
`수직적 규모 확장(scale up)`: 서버에 고사양 자원(더 좋은 CPU, 더 많은 RAM 등)을 추가하는 방법이다.  
`수평적 규모 확장(scale out)`: 더 많은 서버를 추가하여 성능을 개선하는 방법이다.

수직적 확장은 아주 단순한 개념이기 때문에 적은 트래픽이 발생하는 경우 좋은 방법이 될 수 있다.  
하지만 scale up에는 심각한 단점이 존재한다.
* 한 대의 서버에 CPU나 메모리를 무한대로 증설할 방법은 없다.
* 장애에 대한 자동복구 방안이나 다중화 방안을 제시하지 않는다. 서버에 장애가 발생하면 웹사이트/앱은 완전히 중단된다.  

위와 같은 단점 때문에, ***대규모 애플리케이션을 지원하는 데는 수평적 규모 확장법***이 보다 적절하다.


## 로드밸런서
로드밸런서는 부하 분산 집합에 속한 웹 서버들에게 트래픽 부하를 고르게 분산하는 역할을 한다.  
사용자는 로드밸런서의 `공개 IP`(public IP)주소로 접속서버 간 통신에는 `사설 IP`(private IP)주소가 사용된다.

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FbJpnw2%2FbtrtO7C38gQ%2F7kC7aLeThzI64aVupkt360%2Fimg.png" height="470" width="670">  

위 그림과 같이 `scale out`으로 서버를 늘려 장애를 자동복구하지 못하는 문제(no failover)를 해소할 수 있고,  
`로드밸런서의 트래픽 부하 분산`을 통해 웹 계층의 가용성을 향상시킬 수 있다.
* 서버 1에 장애가 발생하면 로드밸런서에 의해 모든 트래픽은 서버2로 전송된다. 따라서 서비스 전체가 다운되는 일을 방지할 수 있다.
* 트래픽의 가파른 증가로 인해 서버 리소스가 부족하다면, `scale out`으로 더 많은 서버를 추가하면 된다.  
그러면 로드밸런스가 자동적으로 트래픽을 분산시켜준다.


## 데이터베이스 다중화
여러 대의 서버가 하나의 데이터베이스로 READ/WRITE 요청을 한다면 데이터 계층에 부하가 발생하므로 데이터베이스 다중화가 필요하다.  
`데이터베이스 다중화`: 서버 사이에 master-slave 관계를 설정하고 데이터 원본은 주서버에, 사본은 부 서버에 저장하는 방식이다.  
* 주(master) 서버: 쓰기 연산, 데이터 원본을 갖는다.
* 부(slave) 서버: 읽기 연산, master 데이터베이스로부터 사본을 전달받아 저장한다. 
* 대부분의 애플리케이션은 읽기 연산의 비중이 훨씬 크기 때문에 일반적으로 부(slave) 데이터베이스의 수가 더 많다.

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FBuXkV%2FbtrtO8hHFKN%2FMD5YhUkbVoHCf5ck2iowhK%2Fimg.png" height="450" width="600">

* 데이터베이스 다중화 이점
  * `더 나은 성능`: write/update와 같은 데이터 변경 연산은 `master` 데이터베이스 서버로만 전달되고, 읽기 연산은 `slave`로 분산된다. 병렬 처리될 수 있는 질의(query)의 수가 늘어나므로 성능이 향상된다.
  * `안정성`: 데이터를 물리적으로 떨어진 여러 장소에 다중화시켜 놓을 수 있으므로, 데이터베이스 서버 일부가 파괴되어도 데이터는 보존된다.
  * `가용성`: 데이터를 여러 slave 서버에 복제해 둠으로써, 하나의 데이터베이스 서버에 장애가 발생해도 다른 서버의 데이터를 가져와 게속 서비스할 수 있다.
 
 * 데이터베이스 서버 중 하나가 다운되는 경우
   * slave가 하나뿐인데 다운되었다면, read 연산은 한시적으로 모두 master로 전달된다.  
     또한 즉시 새로운 slave가 장애 서버를 대체하게 된다.
   * slave가 여러 대인 경우, read 연산은 나머지 slave들로 분산될 것이며, 새로운 salve가 장애 서버를 대체하게 된다.
   * maser가 다운된 경우, slave 서버가 새로운 master 서버가 되고, write 연산은 이어가게 된다.
   * 실제 운영 환경에서는 slave가 최신 상태가 아닐 수 있기 때문에 복구 스트립트로 구멍 난 데이터를 채워줘야 할 수도 있다.  
   이런 문제를 해결하기 위해선 다중 마스터나 원형 다중화 방식을 생각해볼 수 있다.
  
  
## 시스템 구성
로드밸런서와 데이터베이스 다중화를 고려한 시스템 설계이다.

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FcKreUr%2FbtrtMKhg8hr%2Fk8uF3xiBfx5vS2Lq9gmOck%2Fimg.png" height="550" width="700">

1. 사용자는 DNS로부터 로드밸런서의 공개 IP 주소를 받는다.
2. 사용자는 해당 IP주소를 사용해 로드밸런서에 접속한다.
3. HTTP 요청은 서버 1이나 서버 2로 전달된다.
4. 웹 서버는 사용자의 데이터를 `slave` 데이터베이스 서버에서 읽는다.
5. 웹 서버는 데이터 변경 연산(Create, Update, Delete)의 경우 `master` 데이터베이스 서버로 전달한다.


## 캐시
값비싼 연산이나 자주 참조되는 데이터를 메모리에 올려두는 임시 저장소이다.  
애플리케이션의 성능은 데이터베이스를 얼마나 자주 호출하느냐에 크게 좌우되는데, 캐시를 활용하면 성능을 향상시킬 수 있다.

#### 캐시 계층 
`캐시 계층`은 데이터가 잠시 보관되는 곳으로 데이터베이스보다 훨씬 빠르다.  
별도의 캐시 계층을 두면 성능이 개선될뿐만 아니라, 데이터베이스의 부하를 줄이고 캐시 계층의 규모를 독립적으로 확장시킬 수 있다.
<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FcZRAQz%2FbtruomfrEVw%2FMqxFkT6XTZqoTOyJptUcRK%2Fimg.png" height="180" width="600">
* 캐시에 원하는 데이터가 있는 경우 DB에 쿼리를 날리지 않고 서버로 데이터를 반환한다.
* 캐시에 원하는 데이터가 없는 경우 DB에 쿼리를 날려 얻은 데이터를 캐시에 저장한 뒤 서버에 반환한다.

위를 Read-Through Cache Strategy(읽기 주도형 캐시 전략)이라고 한다.

#### 캐시 사용 시 유의할 점
* `캐시 적용 상황`
  *  데이터 갱신이 자주 일어나지 않지만, 참조가 빈번하게 일어난다면 캐시 사용이 적절하다.  
* `캐시할 데이터 속성`
  * 영속적으로 보관할 데이터는 캐시에 적합하지 않다. 캐시 서버가 재시작되면 캐시 내 데이터는 모두 사라지기 때문이다.  
* `캐시 데이터 만료 기간`
  *  캐시에 보관된 데이터의 만료 기간이 너무 짧으면, 데이터베이스를 자주 조회해 성능이 저하되고,  
  너무 길다면 원본 데이터와 차이가 날 가능성이 높아진다.  
* `일관성`
  *  원본 데이터와 캐시 데이터 갱신 연산이 단일 트랜잭션으로 처리되지 않는 경우 데이터의 일관성이 깨질 수 있다.  
  * 저장소 내의 원본과 캐시 내의 사본은 항상 일관성을 유지해야 한다.  
* `장애 대처 방안`
  *  캐시 서버를 한 대만 두는 경우 *단일 장애 지점(SPOF)*이 되어버릴 수 있다. 따라서 여러 지역에 걸쳐 캐시 서버를 분산시켜야 한다.  
    * *단일 장애 지점(SPOF)*: 특정 지점에서의 장애가 전체 시스템의 동작을 중단시켜버리는 경우 해당 지점  
* `캐시 메모리 크기`
  * 캐시 메모리가 너무 작으면 데이터가 캐시에서 자주 밀려나므로 성능이 떨어진다. 
  * 캐시 메모리는 가능한 크게 잡는 것이 유리하다.  
* `데이터 방출 정책`
  * 캐시가 꽉 차면 적절한 캐시 데이터 방출 정책을 적용해 기존 데이터를 내보내야 한다.  
  * LRU, LFU, FIFO 같은 정책들을 사용

> Q. 캐시 메모리를 가능한 크게 잡는 것이 유리한가? 크게 잡았을 때 발생하는 문제는 없나?

## 콘텐츠 전송 네트워크(CDN)
`CDN`은 정적 콘텐츠를 전송하는 데 쓰이는, 지리적으로 분산된 서버의 네트워크이다.  
이미지, 비디오, CSS, JavaScript 파일 등을 캐시할 수 있다.  

당연하겠지만, CDN서버로부터 물리적 거리가 멀어지면 로드되는 속도는 당연히 느려진다.  
만약 넷플릭스의 동영상이 미국 CDN 서버로부터 전송된다고 하면, 미국에서는 빠른 속도로 동영상이 제공되겠지만, 유럽에서는 느리게 제공될 것이다.
<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FbaX1Ug%2FbtruiRtBXn3%2FVJLZxjDPyWJ116mrlUCnBK%2Fimg.png" height="200" width="600">

이는 사용자의 서비스 경험으로 이어지기 때문에 서비스에 악영향을 미칠 수 있다.  
따라서 각 지역에 CDN 서버를 두고 사용자가 요청한 지역과 가장 가까운 CDN 서버로부터 컨텐츠를 전송받게 하는 것이다.
<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2F0X6ru%2FbtrueyBl5aQ%2Fj4mKkpgfGMxMSFsp824Qv0%2Fimg.png" height="200" width="600">
#### CDN의 동작 방식
<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FPkTJU%2FbtrueynQ1bY%2FcZnDDqDl516P8DIMhAr640%2Fimg.png" height="300" width="650">

1. 사용자 A가 이미지 URL을 이용해 `image.png`에 접근한다.
2. CDN 서버의 캐시에 해당 이미지가 없는 경우, 서버는 원본 서버(Amazon S3 ..)에 요청하여 파일을 가져온다.
3. 원본 서버가 CDN 서버에 파일을 반환한다. 헤더에는 캐시의 생명주기 정보인 TTL(Time-To-Live) 값이 들어왔다.
4. CDN 서버는 전달받은 이미지 파일을 캐시에 저장하고, 사용자 A에게 반환한다. 캐시에 저장한 이미지는 TTL에 명시된 시간이 끝날 때까지 캐시된다.
5. 사용자 B가 같은 이미지에 대한 요청을 CDN 서버에 전송한다.
6. 만료되지 않은 이미지에 대한 요청은 캐시를 통해 사용자에게 바로 반환한다.

#### CDN 사용 시 고려 사항
* `비용`
  * 자주 사용되지 않는 콘텐츠를 캐싱하는 것은 이득이 크지 않으므로, CDN에서 제외해 비용을 최적화하자.
* `적절한 만료 시한 설정`
  * 시의성(시간이 지날수록 가치가 떨어짐)이 중요한 컨텐츠의 경우 만료 시간을 잘 정하자.
  * 너무 길면 컨텐츠의 신선도가 떨어지며, 너무 짧으면 원본 서버에 빈번히 접속하게 될 수 있다.
* `CDN 장애에 대한 대처 방안`
  * CDN 서버 자체가 죽었을 경우 서비스에 직접적인 영향이 가지 않도록 시스템을 설계해야 한다.
  * 예를 들어, CDN이 일시적으로 응답하지 않는 경우, 문제를 감지하고 원본 서버로부터 직접 컨텐츠를 전송할 수 있도록 시스템을 구성해야 한다.
* `컨텐츠 무효화 방법`
  * 만료되지 않은 컨텐츠라도 컨텐츠를 무효화할 수 있는 방법을 고려해야 한다.
  * 일반적으로 CDN 서비스에서 제공하는 API를 이용해 컨텐츠를 무효화하거나, 컨텐츠의 다른 버전을 서비스하도록 오브젝트 버저닝을 이용하는 방법이 있다.

## 시스템 구성
CDN과 캐시가 추가된 설계이다.

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2Fdj9QCN%2FbtruqGqXh9z%2F525RdQ4UyK02WI6jDJkaIK%2Fimg.png" height="450" width="600">

1. 정적 콘텐츠(JS, CSS, 이미지 등)는 더 이상 웹 서버를 통해 서비스하지 않으며, CDN을 통해 제공하여 더 나은 성능을 보장한다.
2. 캐시가 데이터베이스 부하를 줄여준다.

## 무상태(stateless) 웹 계층
웹 계층을 수평적으로 확장하기 위해 사용자 세션 데이터와 같은 상태 정보를 웹 계층에서 제거해야 한다.  
바람직한 전략은 상태 정보를 관계형 데이터베이스나 NoSQL 같은 지속성 저장소에 보관하고, 필요할 때 가져오도록 하는 것이다.  
이렇게 구성된 웹 계층을 `무상태 웹 계층`이라고 한다.

#### 상태 정보 의존적인 아키텍처
상태 정보를 보관하는 서버는 클라이언트 정보, 즉 상태를 유지하여 요청들 사이에 공유되도록 한다.

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2Fk8Zeh%2Fbtruexwcpl7%2F7nqYYTBvYWgAyhuTQtaetK%2Fimg.png" height="340" width="500">

그림과 같이 사용자 A의 상태 정보는 서버 1에 저장된다.  
따라서 사용자 A를 인증하기 위해선 반드시 서버 1로 HTTP 요청이 전송되어야 한다.


만약 요청이 서버 2로 전송된다면, 사용자 A에 대한 인증은 실패하게 된다.  
즉, 같은 클라이언트의 요청은 항상 같은 서버로 전송되어야 한다는 것이다.


대부분의 로드밸런서가 이를 지원하기 위해 `고정 세션(sticky session)`이라는 기능을 제공하는데,  
이는 로드밸런서에 부담을 주고, 뒷단에 서버를 추가하거나 제거하기도 까다로워진다.
* sticky session: 고정 세션 기능으로 같은 클라이언트의 요청을 항상 같은 서버로 전송시키는 기능

#### 무상태 아키텍처
서버가 상태 정보를 갖고 있지 않기 때문에 어떤 서버로든 HTTP 요청을 전송될 수 있다.  
웹 서버는 상태 정보가 필요할 경우 공유 저장소로부터 데이터를 가져온다.  

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FdTmEDy%2FbtruokJETbh%2FHOqvKKq5Q28doaxNL5JofK%2Fimg.png" height="370" width="470">

상태 정보는 웹 서버로부터 물리적으로 분리되어 있다.  
이런 구조는 단순하고, 안정적이며, 규모 확장이 쉽다.  

## 시스템 구성
무상태 웹 계층을 갖도록 기존 설계를 변경해 구성한 시스템이다. 

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FO5IGq%2FbtruiPJQoTQ%2FvULArt2JF3G10VuOOeiwfk%2Fimg.png" height="500" width="650">

위 그림은 세션 데이터를 웹 계층에서 분리하고, 공유 저장소에 저장한다.  
이때 공유 저장소는 RDBMS일 수도 있고, Memcached/Redis 같은 캐시 시스템일 수도 있으며, NoSQL일 수도 있다.  









