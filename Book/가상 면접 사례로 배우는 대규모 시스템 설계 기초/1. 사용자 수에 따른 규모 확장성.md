# 사용자 수에 따른 규모 확장성
* [단일 서버](#단일-서버)
* [데이터 베이스](#데이터베이스)
* [수직적 규모 확장 vs 수평적 규모 확장](#수직적-규모-확장-vs-수평적-규모-확장)
* [로드밸런서](#로드밸런서)
* [데이터베이스 다중화](#데이터베이스-다중화)
* [캐시](#캐시)
* [콘텐츠 전송 네트워크(CDN)](#콘텐츠-전송-네트워크cdn)
* [무상태(stateless) 웹 계층](#무상태stateless-웹-계층)
* [데이터 센터](#데이터-센터)
* [메시지 큐](#메시지-큐)
* [데이터베이스 규모 확장](#데이터베이스-규모-확장)
* [정리](#정리)

## 단일 서버
* 사용자의 요청이 처리되는 과정

<img src="https://user-images.githubusercontent.com/50009240/164426609-345c3427-5587-4887-8d77-f0faa60b8605.png" height="370" width="700">

1. 사용자가 웹 브라우저에 URL(도메인 이름) 입력한다.
2. 입력된 URL 정보는 DNS에서 IP 주소로 변환되어 반환된다.
3. 해당 IP주소의 웹 서버로 HTTP 요청이 전달된다.
4. 요청을 받은 웹 서버는 HTML 페이지나 JSON 형턔의 응답을 반환한다.

## 데이터베이스
사용자가 늘면 서버 하나로는 충분하지 않아, 여러 서버를 두어야 한다.  
여러 서버를 두어 하나는 웹/모바일 트래픽 처리 용도, 다른 하나는 데이터베이스용으로 사용한다.  
서버를 분리하면 `웹 계층`과 `데이터 계층` 각각을 독립적으로 확장해 나갈 수 있게 된다.

<img src="https://user-images.githubusercontent.com/50009240/164429189-fc711995-5fb7-489a-bc1b-2204d6cb8f59.png" height="370" width="700">

**어떤 데이터베이스를 사용할 것인가?**  
* `RDBMS`는 자료를 테이블과 열, 칼럼으로 표현한다. 여러 테이블에 있는 데이터를 조인(join)하여 합칠 수 있다.  
* `NoSQL`은 키-값 저장소, 그래프 저장소, 칼럼 저장소, 문서 저장소로 나눌 수 있다. 조인(join) 연산을 지원하지 않는다.
* `RDBMS`를 사용하는 것이 최선일 수 있지만, 아래와 같은 경우에는 `NoSQL`이 바람직한 선택일 수 있다. 
  * 아주 낮은 응답 지연시간(latency)이 요구됨
  * 다루는 데이터가 비정형이라 관게형 데이터가 아님
  * 데이터(JSON, YAML, XML 등)을 직력화하거나 역직렬화할 수 있기만 하면 됨
  * 아주 많은 양의 데이터를 저장할 필요가 있음

## 수직적 규모 확장 vs 수평적 규모 확장
`수직적 규모 확장(scale up)`: 서버에 고사양 자원(더 좋은 CPU, 더 많은 RAM 등)을 추가하는 방법이다.  
`수평적 규모 확장(scale out)`: 더 많은 서버를 추가하여 성능을 개선하는 방법이다.

수직적 확장은 아주 단순한 개념이기 때문에 적은 트래픽이 발생하는 경우 좋은 방법이 될 수 있다.  
하지만 scale up에는 심각한 단점이 존재한다.
* 한 대의 서버에 CPU나 메모리를 무한대로 증설할 방법은 없다.
* 장애에 대한 자동복구 방안이나 다중화 방안을 제시하지 않는다. 서버에 장애가 발생하면 웹사이트/앱은 완전히 중단된다.  

위와 같은 단점 때문에, ***대규모 애플리케이션을 지원하는 데는 수평적 규모 확장법***이 보다 적절하다.


## 로드밸런서
로드밸런서는 부하 분산 집합에 속한 웹 서버들에게 트래픽 부하를 고르게 분산하는 역할을 한다.  
사용자는 로드밸런서의 `공개 IP`(public IP)주소로 접속서버 간 통신에는 `사설 IP`(private IP)주소가 사용된다.

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FbJpnw2%2FbtrtO7C38gQ%2F7kC7aLeThzI64aVupkt360%2Fimg.png" height="470" width="670">  

위 그림과 같이 `scale out`으로 서버를 늘려 장애를 자동복구하지 못하는 문제(no failover)를 해소할 수 있고,  
`로드밸런서의 트래픽 부하 분산`을 통해 웹 계층의 가용성을 향상시킬 수 있다.
* 서버 1에 장애가 발생하면 로드밸런서에 의해 모든 트래픽은 서버2로 전송된다. 따라서 서비스 전체가 다운되는 일을 방지할 수 있다.
* 트래픽의 가파른 증가로 인해 서버 리소스가 부족하다면, `scale out`으로 더 많은 서버를 추가하면 된다.  
그러면 로드밸런스가 자동적으로 트래픽을 분산시켜준다.


## 데이터베이스 다중화
여러 대의 서버가 하나의 데이터베이스로 READ/WRITE 요청을 한다면 데이터 계층에 부하가 발생하므로 데이터베이스 다중화가 필요하다.  
`데이터베이스 다중화`: 서버 사이에 master-slave 관계를 설정하고 데이터 원본은 주서버에, 사본은 부 서버에 저장하는 방식이다.  
* 주(master) 서버: 쓰기 연산, 데이터 원본을 갖는다.
* 부(slave) 서버: 읽기 연산, master 데이터베이스로부터 사본을 전달받아 저장한다. 
* 대부분의 애플리케이션은 읽기 연산의 비중이 훨씬 크기 때문에 일반적으로 부(slave) 데이터베이스의 수가 더 많다.

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FBuXkV%2FbtrtO8hHFKN%2FMD5YhUkbVoHCf5ck2iowhK%2Fimg.png" height="450" width="600">

* 데이터베이스 다중화 이점
  * `더 나은 성능`: write/update와 같은 데이터 변경 연산은 `master` 데이터베이스 서버로만 전달되고, 읽기 연산은 `slave`로 분산된다. 병렬 처리될 수 있는 질의(query)의 수가 늘어나므로 성능이 향상된다.
  * `안정성`: 데이터를 물리적으로 떨어진 여러 장소에 다중화시켜 놓을 수 있으므로, 데이터베이스 서버 일부가 파괴되어도 데이터는 보존된다.
  * `가용성`: 데이터를 여러 slave 서버에 복제해 둠으로써, 하나의 데이터베이스 서버에 장애가 발생해도 다른 서버의 데이터를 가져와 게속 서비스할 수 있다.
 
 * 데이터베이스 서버 중 하나가 다운되는 경우
   * slave가 하나뿐인데 다운되었다면, read 연산은 한시적으로 모두 master로 전달된다.  
     또한 즉시 새로운 slave가 장애 서버를 대체하게 된다.
   * slave가 여러 대인 경우, read 연산은 나머지 slave들로 분산될 것이며, 새로운 salve가 장애 서버를 대체하게 된다.
   * maser가 다운된 경우, slave 서버가 새로운 master 서버가 되고, write 연산은 이어가게 된다.
   * 실제 운영 환경에서는 slave가 최신 상태가 아닐 수 있기 때문에 복구 스트립트로 구멍 난 데이터를 채워줘야 할 수도 있다.  
   이런 문제를 해결하기 위해선 다중 마스터나 원형 다중화 방식을 생각해볼 수 있다.
  
  
## 시스템 구성
로드밸런서와 데이터베이스 다중화를 고려한 시스템 설계이다.

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FcKreUr%2FbtrtMKhg8hr%2Fk8uF3xiBfx5vS2Lq9gmOck%2Fimg.png" height="550" width="700">

1. 사용자는 DNS로부터 로드밸런서의 공개 IP 주소를 받는다.
2. 사용자는 해당 IP주소를 사용해 로드밸런서에 접속한다.
3. HTTP 요청은 서버 1이나 서버 2로 전달된다.
4. 웹 서버는 사용자의 데이터를 `slave` 데이터베이스 서버에서 읽는다.
5. 웹 서버는 데이터 변경 연산(Create, Update, Delete)의 경우 `master` 데이터베이스 서버로 전달한다.


## 캐시
값비싼 연산이나 자주 참조되는 데이터를 메모리에 올려두는 임시 저장소이다.  
애플리케이션의 성능은 데이터베이스를 얼마나 자주 호출하느냐에 크게 좌우되는데, 캐시를 활용하면 성능을 향상시킬 수 있다.

#### 캐시 계층 
`캐시 계층`은 데이터가 잠시 보관되는 곳으로 데이터베이스보다 훨씬 빠르다.  
별도의 캐시 계층을 두면 성능이 개선될뿐만 아니라, 데이터베이스의 부하를 줄이고 캐시 계층의 규모를 독립적으로 확장시킬 수 있다.
<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FcZRAQz%2FbtruomfrEVw%2FMqxFkT6XTZqoTOyJptUcRK%2Fimg.png" height="180" width="600">
* 캐시에 원하는 데이터가 있는 경우 DB에 쿼리를 날리지 않고 서버로 데이터를 반환한다.
* 캐시에 원하는 데이터가 없는 경우 DB에 쿼리를 날려 얻은 데이터를 캐시에 저장한 뒤 서버에 반환한다.

위를 Read-Through Cache Strategy(읽기 주도형 캐시 전략)이라고 한다.

#### 캐시 사용 시 유의할 점
* `캐시 적용 상황`
  *  데이터 갱신이 자주 일어나지 않지만, 참조가 빈번하게 일어난다면 캐시 사용이 적절하다.  
* `캐시할 데이터 속성`
  * 영속적으로 보관할 데이터는 캐시에 적합하지 않다. 캐시 서버가 재시작되면 캐시 내 데이터는 모두 사라지기 때문이다.  
* `캐시 데이터 만료 기간`
  *  캐시에 보관된 데이터의 만료 기간이 너무 짧으면, 데이터베이스를 자주 조회해 성능이 저하되고,  
  너무 길다면 원본 데이터와 차이가 날 가능성이 높아진다.  
* `일관성`
  *  원본 데이터와 캐시 데이터 갱신 연산이 단일 트랜잭션으로 처리되지 않는 경우 데이터의 일관성이 깨질 수 있다.  
  * 저장소 내의 원본과 캐시 내의 사본은 항상 일관성을 유지해야 한다.  
* `장애 대처 방안`
  *  캐시 서버를 한 대만 두는 경우 *단일 장애 지점(SPOF)*이 되어버릴 수 있다. 따라서 여러 지역에 걸쳐 캐시 서버를 분산시켜야 한다.  
    * *단일 장애 지점(SPOF)*: 특정 지점에서의 장애가 전체 시스템의 동작을 중단시켜버리는 경우 해당 지점  
* `캐시 메모리 크기`
  * 캐시 메모리가 너무 작으면 데이터가 캐시에서 자주 밀려나므로 성능이 떨어진다. 
  * 캐시 메모리는 가능한 크게 잡는 것이 유리하다.  
* `데이터 방출 정책`
  * 캐시가 꽉 차면 적절한 캐시 데이터 방출 정책을 적용해 기존 데이터를 내보내야 한다.  
  * LRU, LFU, FIFO 같은 정책들을 사용

> Q. 캐시 메모리를 가능한 크게 잡는 것이 유리한가? 크게 잡았을 때 발생하는 문제는 없나?

## 콘텐츠 전송 네트워크(CDN)
`CDN`은 정적 콘텐츠를 전송하는 데 쓰이는, 지리적으로 분산된 서버의 네트워크이다.  
이미지, 비디오, CSS, JavaScript 파일 등을 캐시할 수 있다.  

당연하겠지만, CDN서버로부터 물리적 거리가 멀어지면 로드되는 속도는 당연히 느려진다.  
만약 넷플릭스의 동영상이 미국 CDN 서버로부터 전송된다고 하면, 미국에서는 빠른 속도로 동영상이 제공되겠지만, 유럽에서는 느리게 제공될 것이다.
<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FbaX1Ug%2FbtruiRtBXn3%2FVJLZxjDPyWJ116mrlUCnBK%2Fimg.png" height="200" width="600">

이는 사용자의 서비스 경험으로 이어지기 때문에 서비스에 악영향을 미칠 수 있다.  
따라서 각 지역에 CDN 서버를 두고 사용자가 요청한 지역과 가장 가까운 CDN 서버로부터 컨텐츠를 전송받게 하는 것이다.
<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2F0X6ru%2FbtrueyBl5aQ%2Fj4mKkpgfGMxMSFsp824Qv0%2Fimg.png" height="200" width="600">
#### CDN의 동작 방식
<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FPkTJU%2FbtrueynQ1bY%2FcZnDDqDl516P8DIMhAr640%2Fimg.png" height="300" width="650">

1. 사용자 A가 이미지 URL을 이용해 `image.png`에 접근한다.
2. CDN 서버의 캐시에 해당 이미지가 없는 경우, 서버는 원본 서버(Amazon S3 ..)에 요청하여 파일을 가져온다.
3. 원본 서버가 CDN 서버에 파일을 반환한다. 헤더에는 캐시의 생명주기 정보인 TTL(Time-To-Live) 값이 들어왔다.
4. CDN 서버는 전달받은 이미지 파일을 캐시에 저장하고, 사용자 A에게 반환한다. 캐시에 저장한 이미지는 TTL에 명시된 시간이 끝날 때까지 캐시된다.
5. 사용자 B가 같은 이미지에 대한 요청을 CDN 서버에 전송한다.
6. 만료되지 않은 이미지에 대한 요청은 캐시를 통해 사용자에게 바로 반환한다.

#### CDN 사용 시 고려 사항
* `비용`
  * 자주 사용되지 않는 콘텐츠를 캐싱하는 것은 이득이 크지 않으므로, CDN에서 제외해 비용을 최적화하자.
* `적절한 만료 시한 설정`
  * 시의성(시간이 지날수록 가치가 떨어짐)이 중요한 컨텐츠의 경우 만료 시간을 잘 정하자.
  * 너무 길면 컨텐츠의 신선도가 떨어지며, 너무 짧으면 원본 서버에 빈번히 접속하게 될 수 있다.
* `CDN 장애에 대한 대처 방안`
  * CDN 서버 자체가 죽었을 경우 서비스에 직접적인 영향이 가지 않도록 시스템을 설계해야 한다.
  * 예를 들어, CDN이 일시적으로 응답하지 않는 경우, 문제를 감지하고 원본 서버로부터 직접 컨텐츠를 전송할 수 있도록 시스템을 구성해야 한다.
* `컨텐츠 무효화 방법`
  * 만료되지 않은 컨텐츠라도 컨텐츠를 무효화할 수 있는 방법을 고려해야 한다.
  * 일반적으로 CDN 서비스에서 제공하는 API를 이용해 컨텐츠를 무효화하거나, 컨텐츠의 다른 버전을 서비스하도록 오브젝트 버저닝을 이용하는 방법이 있다.

## 시스템 구성
CDN과 캐시가 추가된 설계이다.

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2Fdj9QCN%2FbtruqGqXh9z%2F525RdQ4UyK02WI6jDJkaIK%2Fimg.png" height="450" width="600">

1. 정적 콘텐츠(JS, CSS, 이미지 등)는 더 이상 웹 서버를 통해 서비스하지 않으며, CDN을 통해 제공하여 더 나은 성능을 보장한다.
2. 캐시가 데이터베이스 부하를 줄여준다.

## 무상태(stateless) 웹 계층
웹 계층을 수평적으로 확장하기 위해 사용자 세션 데이터와 같은 상태 정보를 웹 계층에서 제거해야 한다.  
바람직한 전략은 상태 정보를 관계형 데이터베이스나 NoSQL 같은 지속성 저장소에 보관하고, 필요할 때 가져오도록 하는 것이다.  
이렇게 구성된 웹 계층을 `무상태 웹 계층`이라고 한다.

#### 상태 정보 의존적인 아키텍처
상태 정보를 보관하는 서버는 클라이언트 정보, 즉 상태를 유지하여 요청들 사이에 공유되도록 한다.

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2Fk8Zeh%2Fbtruexwcpl7%2F7nqYYTBvYWgAyhuTQtaetK%2Fimg.png" height="340" width="500">

그림과 같이 사용자 A의 상태 정보는 서버 1에 저장된다.  
따라서 사용자 A를 인증하기 위해선 반드시 서버 1로 HTTP 요청이 전송되어야 한다.


만약 요청이 서버 2로 전송된다면, 사용자 A에 대한 인증은 실패하게 된다.  
즉, 같은 클라이언트의 요청은 항상 같은 서버로 전송되어야 한다는 것이다.


대부분의 로드밸런서가 이를 지원하기 위해 `고정 세션(sticky session)`이라는 기능을 제공하는데,  
이는 로드밸런서에 부담을 주고, 뒷단에 서버를 추가하거나 제거하기도 까다로워진다.
* sticky session: 고정 세션 기능으로 같은 클라이언트의 요청을 항상 같은 서버로 전송시키는 기능

#### 무상태 아키텍처
서버가 상태 정보를 갖고 있지 않기 때문에 어떤 서버로든 HTTP 요청을 전송될 수 있다.  
웹 서버는 상태 정보가 필요할 경우 공유 저장소로부터 데이터를 가져온다.  

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FdTmEDy%2FbtruokJETbh%2FHOqvKKq5Q28doaxNL5JofK%2Fimg.png" height="370" width="470">

상태 정보는 웹 서버로부터 물리적으로 분리되어 있다.  
이런 구조는 단순하고, 안정적이며, 규모 확장이 쉽다.  

## 시스템 구성
무상태 웹 계층을 갖도록 기존 설계를 변경해 구성한 시스템이다. 

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FO5IGq%2FbtruiPJQoTQ%2FvULArt2JF3G10VuOOeiwfk%2Fimg.png" height="500" width="650">

위 그림은 세션 데이터를 웹 계층에서 분리하고, 공유 저장소에 저장한다.  
이때 공유 저장소는 RDBMS일 수도 있고, Memcached/Redis 같은 캐시 시스템일 수도 있으며, NoSQL일 수도 있다.  

## 데이터 센터
두 개의 데이터 센터(DC1(US-East), DC2(US-West))가 있다고 하자.  
장애가 없는 상황에서 사용자는 가장 가까운 데이터 센터로 안내되는데, 이러한 절차를 `지리적 라우팅`이라고 한다.  
`지리적 라우팅`에서의 geoDNS는 사용자의 위치에 따라 도메인 이름을 어떤 IP 주소로 변환할지 결정할 수 있도록 해주는 DNS서비스다.
> 하나의 Data Center 내에는 WebServer, Database, Cache Server 등이 있다.  
> Load Balancer가 지리적 라우팅을 수행한다.

<img src="https://user-images.githubusercontent.com/45676906/149977074-7a72add4-4e15-416b-9675-cce9529f7669.png" height="500" width="650">

두개 이상의 데이터 센터 중 하나의 데이터 센터에 심각한 장애가 발생하면, 모든 트래픽은 장애가 없는 데이터 센터로 전송된다.  
다중 데이터 센터를 만들려면 아래와 같은 기술적 난제를 해결해야 한다.
* `트래픽 우회`
  * 올바른 데이터 센터로 트래픽을 보내는 효과적인 방법을 찾아야 한다.
  * GeoDNS는 사용자에게서 가장 가까운 데이터센터로 트래픽을 보낼 수 있도록 해 준다.
* `데이터 동기화`
  * 데이터 센터마다 별도의 데이터베이스를 사용하고 있다면, 장애가 자동 복구되어 트래픽이 다른 데이터베이스로 우회된다 해도, 해당 데이터센터에는 찾는 데이터가 없을 수 있다.
  * 따라서 데이터를 여러 데이터센터에 걸쳐 다중화해야 한다.
* `테스트와 배포`
  * 여러 데이터 센터에서 서비스를 테스트해 보는 것이 중요하다.
  * 자동화된 배포 도구는 모든 데이터 센터에 동일한 서비스가 설치되도록 하는 데 중요한 역할을 한다.

## 메시지 큐
메시지의 무손실을 보장하는, 비동기 통신을 지원하는 컴포넌트다.

#### 메시지 큐 아키텍처

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FlJfrc%2FbtrvvbY0kjO%2FqWBJrUmt0UIV6MKUw29p6K%2Fimg.png" height="100" width="600">

1. 입력 서비스(생산자 또는 발행자)가 메시지를 만든다.
2. 입력 서비스는 해당 메시지를 메시지 큐에 발행(publish)한다.
3. 큐에는 소비자 또는 구독자(subscriber)라 불리는 서비스 또는 서버가 연결되어 있는데, 해당 메시지를 받아 그에 맞는 동작을 수행한다.

#### 메시지 큐 이점
* 메시지 큐를 이용하면 서비스 또는 서버 간 결합이 느슨해져서, 규모 확장성이 보장되어야 하는 안정적 애플리케이션을 구성하기 좋다.  
* 생산자는 소비자의 서비스가 다운되어 있어도 메시지를 발행할 수 있고, 반대로 소비자는 생산자가 가용 상태가 아니라도 큐에 들어있는 메시지를 수신할 수 있다.

## 시스템 구성
메시지 큐와 로그, 메트릭 자동화를 적용해 수정한 시스템 구성안이다.

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2Fs0RIK%2FbtrvwInVpM0%2FG3LKCwswR6rpw1wtw39Np0%2Fimg.png" height="430" width="650">

## 데이터베이스 규모 확장
서비스 규모가 커지고 저장할 데이터가 많아지면 데이터베이스에 대한 부하도 증가한다.  
데이터베이스 규모 확장법으로는 웹 서버처럼 `scale up`, `scale out`이 존재한다.

<img src="https://user-images.githubusercontent.com/45676906/149980310-a387b7fa-2093-4d7c-8f4e-068fa4cd5365.png" height="270" width="550">

#### 수직적 확장(Scale Up)
기존 데이터베이스를 고성능의 자원으로 증성하는 방법이다.  
하지만 데이터베이스의 수직적 확장은 몇 가지 심각한 단점이 있다.
* 데이터베이스 서버 하드웨어에는 한계가 있으므로 CPU, RAM 등을 무한 증설할 수는 없다.
* 단일 장애 지점 SPOF로 인한 위험이 있다.
* 고성능으로 갈수록 비용이 비싸진다.


이러한 단점은 수평적 확장으로 해결할 수 있다.  

#### 수평적 확장(Scale Out) - 샤딩
데이터베이스의 수평적 확장은 `샤딩(Sharding)`이라고 한다.  
`샤딩`: 데이터베이스를 샤드(shard)`라고 부르는 작은 단위로 분활하는 기술을 말한다.  
모든 샤드는 같은 스키마를 사용하지만 샤드에 보관되는 데이터에는 중복이 없다.  
샤딩은 사용자 데이터를 어느 샤드에 저장할지 샤딩 key를 통해 결정하기 때문에 샤딩 key가 아주 중요하다.  
* 예시
  * `user_id%4`를 해시함수로 사용하면 각 샤드에는 다음과 같이 데이터가 저장된다.
  <img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FzubOp%2FbtrvK4didqz%2FoK9kiKl3qYUb34S0xwL0l1%2Fimg.png" height="400" width="350">
  
샤딩 key에 따라 데이터가 어떻게 분산될지 결정되므로, 분산 데이터베이스 환경에 아주 중요한 요소로 작용한다.  
샤딩 key에 따라 한 곳으로만 데이터 부하가 집중될 수도 있고, 여러 곳으로 적절히 잘 분산될 수도 있다.  

#### 샤딩 도입시 발생할 수 있는 문제
* `데이터의 재 샤딩`
  * 데이터가 너무 많아져서 하나의 샤드로 감당하기 어려울 때, 데이터 분포 불균형으로 인한 샤드 소진이 발생하는 경우 샤드 Key를 계산하는 함수를 변경하고 데이터를 재배치해야 한다.
  * 이 문제는 *안정 해시(consistent hashing)* 기법을 활용해 해결할 수 있다.
* `유명인사 문제`
  * 특정 샤드에 질의가 집중되어 서버에 과부하가 걸리는 문제다.
  * 예를 들어 SNS 서비스를 구성하는 시스템에서 아리아나 그란데, BTS와 같은 유명인사가 전부 같은 샤드에 저장되는 데이터베이스가 있다고 할 때, 유명인사가 저장되지 않는 샤드에는 부하가 없지만, 유명인사를 담고 있는 샤드에는 엄청난 read 연산으로 인해 과부하가 생기게 된다.
  * 단순히 user_id로 샤딩 key를 구성했다면 이러한 문제를 해결할 수 있을까?
  * 이 문제를 풀려면 유명인사를 각 샤드에 분산시켜 할당할 수 있는 전략이 필요해진다.
* `조인과 비정규화`
  * 하나의 데이터베이스를 여러 개의 샤드로 분리하고 나면, 분산된 데이터를 조인하기 힘들어진다.  
  * 이를 해결하는 방법은 데이터베이스를 비정규화하여 하나의 테이블에서 질의가 수행될 수 있도록 하는 것이다.
  
> Q. 비정규화한다는 의미를 정확히 모르겠습니다. 비정규화를 하면 데이터베이스가 어떻게 되는건가요?

## 시스템 구성하기
데이터베이스 샤딩을 적용한 아키텍처

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FcD2hpH%2FbtrvMdU8dOG%2Fw4ylmtyEsKom3cqy8jMy21%2Fimg.png" height="450" width="670">

## 정리
* 웹 계층은 무상태 계층으로 
* 모든 계층에 다중화 도입
* 가능한 한 많은 데이터를 캐시할 것
* 여러 데이터 센터를 지원할 것
* 정적 콘텐츠는 CDN을 통해 서비스할 것
* 데이터 계층은 샤딩을 통해 그 규모를 확장할 것
* 각 계층은 독립적 서비스로 분할할 것
* 시스템을 지속적으로 모니터링하고, 자동화 도구들을 사용할 것


> 지금까지 잘 따라와 준 여러분, 축하한다. 훌륭히 해낸 자신을 아낌없이 격려하도록 하자!















