# 처리율 제한 장치의 설계
처리율 제한 장치는 클라이언트 또는 서비스가 보내는 트래픽의 처리율을 제어하는 장치이다.  
HTTP를 예로 들면 특정 기간 내에 전송되는 클라이언트의 요청 횟수를 제한한다.  
API 요청 횟수가 임계치를 넘어서면 이후 모든 호출은 중단된다.  
다음은 몇 가지 사례다.  
* 사용자는 초당 2회 이상 새 글을 올릴 수 없다.
* 같은 IP 주소로는 하루에 10개 이상의 계정을 생성할 수 없다.
* 같은 디바이스로는 주당 5회 이상 리워드(reward)를 요청할 수 없다.

거의 대부분의 대형 IT 서비스 기업들은 처리율 제한 장치를 가지고 있다.  
API에 처리율 제한 장치를 두면 좋은 점은 다음과 같다.
* DoS 공격에 의한 자원 고갈을 방지할 수 있다.
* 비용을 절감할 수 있다.
* 서버 과부화를 방지할 수 있다.

단일 호스트로부터 들어오는 추가 요청에 대해서는 처리를 중단함으로써 Dos 공격을 방지할 수 있고,  
요청 제한을 통해 제3자(third-party) API 호출 비용을 절감할 수 있으며,  
봇이나 잘못된 이용 패턴으로 발생하는 트래픽을 걸래냄으로써 서버 과부화를 방지할 수 있다.  

## 처리율 제한 장치 구축 위치
직관적으로 보자면 처리율 제한 장치는 **클라이언트 측**에 둘 수도 있고, **서버 측**에 둘 수도 있다.  
클라이언트의 요청은 쉽게 위변조가 가능하다.  
모든 클라이언트의 구현을 서버에서 통제하는 것도 어려울 수 있다.  
그러므로, 처리율 제한 장치를 ***클라이언트 측에 두는 것은 적절하지 않다.***


서버 측에 두는 경우 처리율 제한 장치를 API 서버에 둘 수 있지만, 다른 방법도 있다.  
**처리율 제한 미들웨어**를 만들어 클라이언트와 API 서버 사이에 두고, API 서버로 가는 요청을 통제하도록 하는 것이다.  
<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FlDIKZ%2FbtrwZZJRQGB%2FeSOabnzZv6XkTM25qxnIO1%2Fimg.png"  width="650" height="200">

위 그림의 예시로, API 서버의 처리율이 초당 2개의 요청으로 제한된 상황에서, 같은 초 범위 내 3개의 요청이 들어왔다고 해보자.  
앞선 두 요청은 API 서버로 전송될 것이고, 세번째 요청은 처리율 제한 미들웨어에 의해 가로막히고 클라이언트로 HTTP 상태 코드 429가 반환된다.  


마이크로 서비스의 경우 보통 API 게트웨이에 처리율 제한 장치를 구축한다.  
API 게이트웨이는 처리율 제한, SSL 종단, 사용자 인증, IP 허용 목록 관리 등을 지원한다.


## 처리율 제한 알고리즘
처리율 제한을 실현하는 알고리즘에는 어떤 것들이 있고 각각 어떤 장단점을 가지고 있는지 개략적으로 알아보자.

## 토큰 버킷 알고리즘
버킷 크기, 토큰 공급률 2개의 인자를 받아 처리율을 제한한다.  
* 버킷 크기: 버킷에 담을 수 있는 토큰의 최대 개수
* 토큰 공급률(refill rate): 초당 몇 개의 토큰이 버킷에 공급되는가

각 요청은 하나의 토큰을 소비하며 버킷에 주기적으로 공급되는 토큰의 존재 여부에 따라 요청을 전달할지, 버릴지를 결정한다.  
다음은 버킷 크기가 4이고, 토큰 공급률이 분당 4인 토큰 버킷 알고리즘의 예시이다.  
<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FkOULE%2Fbtrw6437TwC%2FQRPjOUdzbXUhhnwpbHVOUK%2Fimg.png"  width="400" height="500">

* 장점
  * 구현이 쉽다.
  * 메모리 사용 측면에서 효율적이다.
  * 버킷에 토큰이 충분하기만 하면 시스템에 전달되기 때문에 짧은 시간에 집중되는 트래픽도 처리 가능하다.
* 단점
  * 2개의 인자에 대한 최적화 튜닝이 까다롭다.

## 누출 버킷 알고리즘
토큰 버킷 알고리즘과 비슷하지만, 요청 처리율이 고정되어 있다는 점이 다르다.  
누출 버킷 알고리즘은 버킷 크기, 처리율 2개의 인자를 받고 큐(Queue)로 구현한다.
* 버킷 크기: 큐 사이즈와 같은 값이다. 큐에는 처리될 항목들이 보관된다.
* 처리율(outflow rate): 지정된 시간당 몇 개의 항목을 처리할지 지정하는 값이다. 보통 초 단위로 표현된다.

동작 원리
1. 요청이 도착하면 큐가 가득 차 있는지 본다.  빈자리가 있는 경우에는 큐에 요청을 추가한다.
2. 큐가 가득 차 있는 경우에는 새 요청은 버린다.
3. 지정된 시간마다 큐에서 요청을 꺼내어 처리한다.

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FbVzzqo%2Fbtrw6fx30wm%2F2KjDbZbcAKSKuFLMxcxIEk%2Fimg.png"  width="600" height="250">

* 장점  
 * 큐의 크기가 제한되어 있어 메모리 사용량 측면에서 효율적이다.  
  * 고정된 처리율을 가지고 있어 안정적 출력이 가능하다.
* 단점  
  * 단시간에 몰리는 트래픽의 경우 큐에는 오래된 요청들이 쌓이게 되고, 제때 처리되지 못하면 최신 요청들이 버려지게 된다.  
  * 2개의 인자에 대한 최적화 튜닝이 까다롭다.

## 고정 윈도 카운터 알고리즘
타임라인을 고정된 간격의 윈도로 나누고, 각 윈도마다 카운터를 붙여 처리율을 제한하는 알고리즘이다.

동작 원리
1. 타임라인은 고정된 간격의 윈도로 나누고, 각 윈도마다 카운터를 붙인다.
2. 요청이 접수될 때마다 카운터의 값을 1씩 증가시킨다.
3. 카운터의 값이 설정해 둔 임계치에 도달하면 새로운 요청은 새 윈도가 열릴 때까지 버려진다.

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FdTH9m0%2Fbtrw8OGuUY0%2FYne7N2iKjpn6XK4IuRoCGK%2Fimg.png"  width="550" height="250">

예시)  
위 그림에서 타임라인의 시간 단위는 1초이다. 시스템은 초당 3개까지의 요청만을 허용한다.  
매초마다 열리는 윈도에 3개 이상의 요청이 밀려오면 초과분은 그림과 같이 버려진다.  


이 알고리즘의 가장 큰 문제는 윈도의 경계 부근에 순간적으로 많은 트래픽이 집중될 경우 윈도에 할당된 양보다 더 많은 요청이 처리될 수 있다는 것이다.  
<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2Fddq7jY%2Fbtrw6friSMA%2FokDe2nDqA7VQDHGt0SNCJK%2Fimg.png"  width="550" height="250">

예시)
위 그림에서 예로 든 시스템은 분당 최대 5개의 요청만을 허용하는 시스템이다. 카운터는 매분마다 초기화된다.  
위 그림에서는 2:00:00와 2:01:00 사이에 다섯 개의 요청이 들어왔고, 2:01:00과 2:02:00 사이에 또 다섯 개의 요청이 들어왔다.  
윈도 위치를 조금 옮겨 2:00:30부터 2:01:30까지의 1분 동안을 살펴보면, 이때 시스템이 처리한 요청은 10개이다.  
허용 한도의 2배인 것이다. 

* 장점
  * 메모리 효율이 좋다.
  * 이해하기 쉽다.
  * 특정 트래픽 패턴을 처리하기에 좋다. 
* 단점
  * 윈도 경계 부근에 일시적으로 많은 트래픽이 몰릴 경우, 시스템의 처리한도보다 많은 양의 요청을 처리하게 된다.

## 이동 윈도 로깅 알고리즘
고정 윈도 카운터 알고리즘의 단점을 해결한 알고리즘이다.  


동작 원리
1. 요청의 타임스탬프를 추적한다. 타임스탬프 데이터는 redis의 sorted set같은 캐시에 보관한다.
2. 새 요청이 들어오면 만료된 타임스탬프를 제거한다.
3. 새 요청의 타임스탬프를 로그에 추가한다.
4. 로그의 크기가 허용치보다 같거나 작으면 요청을 전달하고, 그렇지 않다면 처리를 거부한다.
<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2F1YwvW%2Fbtrw44w5OB4%2FDw8Bj45B5GYlhom6IHxHnk%2Fimg.png"  width="500" height="400">

* 장점
  * 처리율 제한 메커니즘이 정교하다. 즉, 허용되는 요청의 개수는 시스템의 처리율 한도를 넘지 않고 정교하게 지켜진다.
* 단점
  * 거부된 요청의 타임스탬프도 보관하므로 메모리를 많이 사용한다.


## 이동 윈도 카운터 알고리즘
고정 윈도 카운터 알고리즘과 이동 윈도 로깅 알고리즘을 결합한 알고리즘이다.  
다음과 같이 현재 윈도의 요청 수를 계산하고 처리할 수 있다.  
> 현재 1분간의 요청 수 + 직전 1분간의 요청 수 * 이동 윈도와 직전 1분이 겹치는 비율

* 장점
  * 이전 시간대의 평균 처리율에 따라 현재 윈도의 상태를 계산하므로 짧은 시간에 몰리는 트래픽에도 잘 대응한다.
  * 메모리 효율이 좋다.
* 단점
  * 직전 시간대에 도착한 요청이 균등하게 분포되어 있다고 가정한 상태에서 추정치를 계산하기 때문에 다소 느슨한다.
  * 위 단점은 심각한 단점은 아니다.

## 처리율 제한 장치의 구조
처리율 제한 알고리즘의 기본 아이디어는 얼마나 많은 요청이 접수되었는지 추적하는 카운터를 두고, 한도를 넘어서면 이후 요청은 거부하는 것이다.  


### 그렇다면 카운터는 어디에 저장해야 할까?  
데이터베이스는 디스크 접근 때문에 느려서 적합하지 않고, 메모리상에서 동작하는 캐시가 바람직하다.  
캐시는 빠르고, 시간에 기반한 만료 정책을 지원하기 때문에 적합하다.  
따라서 처리율 제한 장치를 구현할 때 자주 사용되는 메모리 기반 저장장치로 Redis를 많이 사용한다.  
처리율 제한 장치는 다음과 같이 동작한다.  

1. 클라이언트가 처리율 제한 미들웨어에 요청을 보낸다.
2. 미들웨어는 redis의 버킷에서 카운터를 가져와 한도를 검사한다.
3. 한도에 도달했다면 해당 요청은 거부된다.
4. 한도에 도달하지 않았다면 API 서버로 요청을 전달하고 카운터 값을 증가시킨 후 redis에 저장한다.

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FmHnLH%2Fbtrw635ekim%2FKscoSlHRLF0I9uIoKzykA0%2Fimg.png"  width="550" height="250">

### 처리율 한도 초과 트래픽의 처리
어떤 요청이 Rate Limit에 걸리면, API는 HTTP 429(Too Many Requests) 응답을 보낸다.  
경우에 따라서는 rate limit에 걸린 메시지를 나중에 처리하기 위해 queue에 보관할 수도 있다.  

### 처리율 제한 장치가 사용하는 HTTP 헤더
클라이언트는 자신의 요청이 한도 초과 되었다는 사실을 알 수 없다.  
따라서 처리율 제한 장치는 Header를 이용해 아래의 정보를 클라이언트에게 전달한다.  

* `X-Ratelimit-Remaining`: 윈도 내 남은 처리 가능 요청 수
* `X-Ratelimit-Limit`: 매 윈도마다 클라이언트가 전송할 수 있는 요청의 수
* `X-Ratelimit-Retry-After`: 한도 제한에 걸리지 않기 위해 몇 초 뒤에 요청을 다시 보내야 하는지 알림

처리율 제한 장치의 상세 구조를 살펴보면 다음과 같다.

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FxPCEl%2Fbtrw63KUWDR%2FcrNFFOVCAM6IKeYhINzcMK%2Fimg.png"  width="600" height="500">









