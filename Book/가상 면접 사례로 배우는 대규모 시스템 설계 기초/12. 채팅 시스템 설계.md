# 채팅 시스템 설계
채팅 앱에는 1:1 채팅(페이스북 메신저)이나 그룹 채팅(Slack)같이 업무 혹은 개인 메시지에 특화된 채팅 시스템이나, 게임 등에 특화된 음성 채팅(Discord) 등이 존재하는데, 이번 장에서는 카카오톡이나 페이스북 메신저와 같은 1:1 채팅과 그룹 채팅에 특화된 채팅 앱을 개략적으로 알아본다.

## 개략적인 요구사항
* 응답지연(latency)이 낮은 1:1 채팅 가능
* 최대 100명까지 참여할 수 있는 그룹 채팅 가능
* 사용자의 접속상태 표시 기능
* 다양한 단말 지원. 하나의 계정으로 여러 단말에 동시 접속 지원
* 푸시 알림
* DAU(일별 능동 사용자 수) 5천만명 처리

## 채팅의 기본 기능과 프로토콜
채팅 시스템의 경우, 클라이언트는 모바일 앱 또는 웹 애플리케이션이다.  
클라이언트들은 서로 직접 통신하지 않고, 채팅 서비스와 통신한다. 아래는 채팅 서비스가 제공하는 기본 기능이다.  
* 클라이언트들로부터 메시지 수신
* 메시지 수신자(recipient) 결정 및 전달
* 수신자가 접속(online) 상태가 아닌 경우에는 접속할 때까지 해당 메시지 보관

아래는 클라이언트(메시지 송신 클라이언트와 수신 클라이언트)와 채팅 서비스 사이의 관계를 나타낸 그림이다.  

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FdeI8pM%2FbtrBqHZDJzV%2FiZKzLNAk9sbkNFB73mTWDK%2Fimg.png"  width="600" height="140">

채팅을 시작하려는 클라이언트는 네트워크 통신 프로토콜을 이용하여 서비스에 접속한다.  
따라서 채팅 서비스의 경우 어떤 통신 프로토콜을 사용할 것인지가 중요한 요소이다.  
위 그림에서 클라이언트는 채팅 서비스에 HTTP 프로토콜로 연결한 다음 메시지를 보내, 수신자에게 해당 메시지를 전달하라고 알린다.  
  * 이때 keep-alive 헤더를 사용하면 클라이언트-서버 사이의 연결을 끊지 않고 계속 유지해 TCP 접속 과정에서 발생하는  
    핸드셰이크(hand-shake) 횟수를 줄일 수 있다.  
  * 하지만 메시지 수신 시나리오는 이것보다 복잡하고 서버에서 클라이언트로 임의 시점에 메시지를 보내는데 쉽게 쓰일 수 없는 문제가 존재한다.    

따라서 이를 해결하기 위해 **폴링(polling), 롱 폴링(long poll-ing), 웹소켓(WebSocket)** 등 다양한 기법들이 제안되어 왔다.

## 폴링(polling)
폴링 기법은 클라이언트가 주기적으로 서버에게 새 메시지가 있냐고 물어보는 방법이다.  
폴링 비용은 폴링을 자주하면 할수록 올라간다. 따라서 서버에서 답해줄 메시지가 없는 경우 서버 자원이 불필요하게 낭비된다.  

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FAJU6v%2FbtrBst0bAvl%2FzWfVmX1WdnaPoId7FUnDHK%2Fimg.png"  width="530" height="620">

## 롱 폴링(long polling)
롱 폴링은 폴링의 비효율적인 부분을 개선한 기법이다.  

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FFBkki%2FbtrBst6WDhe%2FFaB5C504UwMuxCkgiTJsBK%2Fimg.png"  width="530" height="620">

롱 폴링은 주기적으로 새 메시지가 있는지 확인하는 대신, 새 메시지가 반환되거나 타임 아웃될 때까지 연결을 유지한다.  
새 메시지를 받으면 기존 연결을 종료하고, 서버에 새로운 요청을 보내어 모든 절차를 다시 시작한다.  
롱 폴링에는 다음과 같은 약점이 있다.
* HTTP 서버들은 일반적으로 무상태(stateless) 서버이므로 메시지를 보내는 클라이언트와 수신하는 클라이언트가 같은 채팅 서버에 접속하지 않을 수 있다.
  * 로드밸런싱을 위해 라운드 로빈(round robin) 알고리즘을 사용하는 경우, 메시지를 받은 서버는 해당 메싲를 수신할 클라이언트와의 롱 폴링 연결을 가지고 있지 않은 서버일 수 있는 것이다.
* 서버 입장에서는 클라이언트가 연결을 해제했는지 아닌지 알 수 있는 좋은 방법이 없다.
* 메시지를 많이 받지 않는 클라이언트도 타임아웃이 일어날 때마다 주기적으로 서버에 다시 접속해야 하므로 비효율적이다.

## 웹 소켓(WebSocket)
웹소켓(WebSocket)은 서버가 클라이언트에게 비동기 메시지를 보낼 때 가장 널리 사용하는 기술이다.

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FbGWfzR%2FbtrBq7KAqSE%2FTWWh8WYtu0tkSKOXGGzEuk%2Fimg.png"  width="530" height="430">

클라이언트가 웹소켓 연결을 시작하고, 한번 맺어진 연결은 양방향으로 이루어진다.  
처음에는 HTTP 연결이지만, 특정 핸드셰이크 절차를 거치면 웹소켓 연결로 변경되고, 서버는 클라이언트에게 비동기적으로 메시지를 전송할 수 있다.  
웹소켓은 80이나 443처럼 HTTP 혹은, HTTPS 프로토콜이 상용하는 기본 포트번호를 그대로 사용하기 때문에 방화벽이 있는 환경에서도 잘 동작한다.  





